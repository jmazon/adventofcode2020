---
title:       "AoC day 3: Toboggan Trajectory"
author:      "Jean-Baptiste Mazon"
date:        "2020-12-03T10:22:58+01:00"
updated:     "2021-01-01T21:17:58+01:00"
tags:        ["advent of code", aoc2020, haskell]
description: "Rationalizing trees with list splitters"
image:       aoc-2020-03.jpeg
---

[Today's challenge][aoc] can be solved by simple implementation.  This
post is [literate Haskell][lit].

[aoc]: https://adventofcode.com/2020/day/3
[lit]: https://github.com/jmazon/adventofcode2020/blob/master/day03.lhs


> import Data.List.Split
>
> main :: IO ()
> main = do

The input is a subset of the local geology.  The full geology is
obtained by repeating the pattern as many times as necessary along the
horizontal dimension.

So no need for intricate parsing, I'll store it just about as is.

>   geology <- lines <$> readFile "day03.in"

Now to count trees along a provided slope.  

>   let slope right down =

I'll generate the list of positions encountered, and count those that
are a tree.

>         length $ filter (== '#') $

To generate the positions, I'll use a helper function that extracts a
position from a pattern line and an X coordinate.

>         zipWith (\row i -> row !! (i `mod` length row))

The pattern lines are already what's stored in the `geology` variable,
so I'd use it directly.  Except for part 2, where one of the slopes
skips a line out of two.  So I use `chunksOf` to generalize the
skipping aspect.

>           (map head (chunksOf down geology))

The X coordinates are a simple arithmetic sequence, generated by
built-in syntax for enumerations.

>           [0,right..]

The rest if wrapping: a single count for part 1, the product of
multiple counts for part 2.

>   print $ slope 3 1
>   print $ product $ [ slope 1 1, slope 3 1, slope 5 1, slope 7 1, slope 1 2 ]

This concludes today's solution.  See you soon!
